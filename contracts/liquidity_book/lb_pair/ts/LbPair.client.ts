/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { Coin, StdFee } from "@cosmjs/amino";
import {
  CosmWasmClient,
  ExecuteResult,
  SigningCosmWasmClient,
} from "@cosmjs/cosmwasm-stargate";
import {
  ActiveIdResponse,
  BinStepResponse,
  BinUpdatingHeightsResponse,
  Binary,
  ContractStatus,
  FactoryResponse,
  GetPairInfoResponse,
  IdFromPriceResponse,
  LbTokenResponse,
  LiquidityParameters,
  NextNonEmptyBinResponse,
  OracleParametersResponse,
  OracleSampleAtResponse,
  PriceFromIdResponse,
  ProtocolFeesResponse,
  RemoveLiquidity,
  ReservesResponse,
  RewardsDistributionAlgorithm,
  RewardsDistributionResponse,
  StakingResponse,
  StaticFeeParametersResponse,
  SwapInResponse,
  SwapOutResponse,
  SwapSimulationResponse,
  TokenAmount,
  TokenXResponse,
  TokenYResponse,
  TokensResponse,
  TotalSupplyResponse,
  Uint128,
  Uint256,
  UpdatedBinsAfterHeightResponse,
  UpdatedBinsAtHeightResponse,
  UpdatedBinsAtMultipleHeightResponse,
  VariableFeeParametersResponse,
} from "./LbPair.types";
export interface LbPairReadOnlyInterface {
  contractAddress: string;
  getStakingContract: () => Promise<StakingResponse>;
  getLbToken: () => Promise<LbTokenResponse>;
  getPairInfo: () => Promise<GetPairInfoResponse>;
  swapSimulation: ({
    excludeFee,
    offer,
  }: {
    excludeFee?: boolean;
    offer: TokenAmount;
  }) => Promise<SwapSimulationResponse>;
  getFactory: () => Promise<FactoryResponse>;
  getTokens: () => Promise<TokensResponse>;
  getTokenX: () => Promise<TokenXResponse>;
  getTokenY: () => Promise<TokenYResponse>;
  getBinStep: () => Promise<BinStepResponse>;
  getReserves: () => Promise<ReservesResponse>;
  getActiveId: () => Promise<ActiveIdResponse>;
  getBinReserves: ({ id }: { id: number }) => Promise<ReservesResponse>;
  getBinsReserves: ({ ids }: { ids: number[] }) => Promise<ReservesResponse>;
  getAllBinsReserves: ({
    id,
    page,
    pageSize,
  }: {
    id?: number;
    page?: number;
    pageSize?: number;
  }) => Promise<ReservesResponse>;
  getUpdatedBinAtHeight: ({
    height,
  }: {
    height: number;
  }) => Promise<UpdatedBinsAtHeightResponse>;
  getUpdatedBinAtMultipleHeights: ({
    heights,
  }: {
    heights: number[];
  }) => Promise<UpdatedBinsAtMultipleHeightResponse>;
  getUpdatedBinAfterHeight: ({
    height,
    page,
    pageSize,
  }: {
    height: number;
    page?: number;
    pageSize?: number;
  }) => Promise<UpdatedBinsAfterHeightResponse>;
  getBinUpdatingHeights: ({
    page,
    pageSize,
  }: {
    page?: number;
    pageSize?: number;
  }) => Promise<BinUpdatingHeightsResponse>;
  getNextNonEmptyBin: ({
    id,
    swapForY,
  }: {
    id: number;
    swapForY: boolean;
  }) => Promise<NextNonEmptyBinResponse>;
  getProtocolFees: () => Promise<ProtocolFeesResponse>;
  getStaticFeeParameters: () => Promise<StaticFeeParametersResponse>;
  getVariableFeeParameters: () => Promise<VariableFeeParametersResponse>;
  getOracleParameters: () => Promise<OracleParametersResponse>;
  getOracleSampleAt: ({
    lookUpTimestamp,
  }: {
    lookUpTimestamp: number;
  }) => Promise<OracleSampleAtResponse>;
  getPriceFromId: ({ id }: { id: number }) => Promise<PriceFromIdResponse>;
  getIdFromPrice: ({
    price,
  }: {
    price: Uint256;
  }) => Promise<IdFromPriceResponse>;
  getSwapIn: ({
    amountOut,
    swapForY,
  }: {
    amountOut: Uint128;
    swapForY: boolean;
  }) => Promise<SwapInResponse>;
  getSwapOut: ({
    amountIn,
    swapForY,
  }: {
    amountIn: Uint128;
    swapForY: boolean;
  }) => Promise<SwapOutResponse>;
  totalSupply: ({ id }: { id: number }) => Promise<TotalSupplyResponse>;
  getRewardsDistribution: ({
    epochId,
  }: {
    epochId?: number;
  }) => Promise<RewardsDistributionResponse>;
}
export class LbPairQueryClient implements LbPairReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getStakingContract = this.getStakingContract.bind(this);
    this.getLbToken = this.getLbToken.bind(this);
    this.getPairInfo = this.getPairInfo.bind(this);
    this.swapSimulation = this.swapSimulation.bind(this);
    this.getFactory = this.getFactory.bind(this);
    this.getTokens = this.getTokens.bind(this);
    this.getTokenX = this.getTokenX.bind(this);
    this.getTokenY = this.getTokenY.bind(this);
    this.getBinStep = this.getBinStep.bind(this);
    this.getReserves = this.getReserves.bind(this);
    this.getActiveId = this.getActiveId.bind(this);
    this.getBinReserves = this.getBinReserves.bind(this);
    this.getBinsReserves = this.getBinsReserves.bind(this);
    this.getAllBinsReserves = this.getAllBinsReserves.bind(this);
    this.getUpdatedBinAtHeight = this.getUpdatedBinAtHeight.bind(this);
    this.getUpdatedBinAtMultipleHeights =
      this.getUpdatedBinAtMultipleHeights.bind(this);
    this.getUpdatedBinAfterHeight = this.getUpdatedBinAfterHeight.bind(this);
    this.getBinUpdatingHeights = this.getBinUpdatingHeights.bind(this);
    this.getNextNonEmptyBin = this.getNextNonEmptyBin.bind(this);
    this.getProtocolFees = this.getProtocolFees.bind(this);
    this.getStaticFeeParameters = this.getStaticFeeParameters.bind(this);
    this.getVariableFeeParameters = this.getVariableFeeParameters.bind(this);
    this.getOracleParameters = this.getOracleParameters.bind(this);
    this.getOracleSampleAt = this.getOracleSampleAt.bind(this);
    this.getPriceFromId = this.getPriceFromId.bind(this);
    this.getIdFromPrice = this.getIdFromPrice.bind(this);
    this.getSwapIn = this.getSwapIn.bind(this);
    this.getSwapOut = this.getSwapOut.bind(this);
    this.totalSupply = this.totalSupply.bind(this);
    this.getRewardsDistribution = this.getRewardsDistribution.bind(this);
  }

  getStakingContract = async (): Promise<StakingResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_staking_contract: {},
    });
  };
  getLbToken = async (): Promise<LbTokenResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_lb_token: {},
    });
  };
  getPairInfo = async (): Promise<GetPairInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pair_info: {},
    });
  };
  swapSimulation = async ({
    excludeFee,
    offer,
  }: {
    excludeFee?: boolean;
    offer: TokenAmount;
  }): Promise<SwapSimulationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      swap_simulation: {
        exclude_fee: excludeFee,
        offer,
      },
    });
  };
  getFactory = async (): Promise<FactoryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_factory: {},
    });
  };
  getTokens = async (): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_tokens: {},
    });
  };
  getTokenX = async (): Promise<TokenXResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_token_x: {},
    });
  };
  getTokenY = async (): Promise<TokenYResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_token_y: {},
    });
  };
  getBinStep = async (): Promise<BinStepResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_bin_step: {},
    });
  };
  getReserves = async (): Promise<ReservesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_reserves: {},
    });
  };
  getActiveId = async (): Promise<ActiveIdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_active_id: {},
    });
  };
  getBinReserves = async ({
    id,
  }: {
    id: number;
  }): Promise<ReservesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_bin_reserves: {
        id,
      },
    });
  };
  getBinsReserves = async ({
    ids,
  }: {
    ids: number[];
  }): Promise<ReservesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_bins_reserves: {
        ids,
      },
    });
  };
  getAllBinsReserves = async ({
    id,
    page,
    pageSize,
  }: {
    id?: number;
    page?: number;
    pageSize?: number;
  }): Promise<ReservesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_bins_reserves: {
        id,
        page,
        page_size: pageSize,
      },
    });
  };
  getUpdatedBinAtHeight = async ({
    height,
  }: {
    height: number;
  }): Promise<UpdatedBinsAtHeightResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_updated_bin_at_height: {
        height,
      },
    });
  };
  getUpdatedBinAtMultipleHeights = async ({
    heights,
  }: {
    heights: number[];
  }): Promise<UpdatedBinsAtMultipleHeightResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_updated_bin_at_multiple_heights: {
        heights,
      },
    });
  };
  getUpdatedBinAfterHeight = async ({
    height,
    page,
    pageSize,
  }: {
    height: number;
    page?: number;
    pageSize?: number;
  }): Promise<UpdatedBinsAfterHeightResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_updated_bin_after_height: {
        height,
        page,
        page_size: pageSize,
      },
    });
  };
  getBinUpdatingHeights = async ({
    page,
    pageSize,
  }: {
    page?: number;
    pageSize?: number;
  }): Promise<BinUpdatingHeightsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_bin_updating_heights: {
        page,
        page_size: pageSize,
      },
    });
  };
  getNextNonEmptyBin = async ({
    id,
    swapForY,
  }: {
    id: number;
    swapForY: boolean;
  }): Promise<NextNonEmptyBinResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_next_non_empty_bin: {
        id,
        swap_for_y: swapForY,
      },
    });
  };
  getProtocolFees = async (): Promise<ProtocolFeesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_protocol_fees: {},
    });
  };
  getStaticFeeParameters = async (): Promise<StaticFeeParametersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_static_fee_parameters: {},
    });
  };
  getVariableFeeParameters =
    async (): Promise<VariableFeeParametersResponse> => {
      return this.client.queryContractSmart(this.contractAddress, {
        get_variable_fee_parameters: {},
      });
    };
  getOracleParameters = async (): Promise<OracleParametersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_oracle_parameters: {},
    });
  };
  getOracleSampleAt = async ({
    lookUpTimestamp,
  }: {
    lookUpTimestamp: number;
  }): Promise<OracleSampleAtResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_oracle_sample_at: {
        look_up_timestamp: lookUpTimestamp,
      },
    });
  };
  getPriceFromId = async ({
    id,
  }: {
    id: number;
  }): Promise<PriceFromIdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_price_from_id: {
        id,
      },
    });
  };
  getIdFromPrice = async ({
    price,
  }: {
    price: Uint256;
  }): Promise<IdFromPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_id_from_price: {
        price,
      },
    });
  };
  getSwapIn = async ({
    amountOut,
    swapForY,
  }: {
    amountOut: Uint128;
    swapForY: boolean;
  }): Promise<SwapInResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_swap_in: {
        amount_out: amountOut,
        swap_for_y: swapForY,
      },
    });
  };
  getSwapOut = async ({
    amountIn,
    swapForY,
  }: {
    amountIn: Uint128;
    swapForY: boolean;
  }): Promise<SwapOutResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_swap_out: {
        amount_in: amountIn,
        swap_for_y: swapForY,
      },
    });
  };
  totalSupply = async ({
    id,
  }: {
    id: number;
  }): Promise<TotalSupplyResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_supply: {
        id,
      },
    });
  };
  getRewardsDistribution = async ({
    epochId,
  }: {
    epochId?: number;
  }): Promise<RewardsDistributionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewards_distribution: {
        epoch_id: epochId,
      },
    });
  };
}
export interface LbPairInterface extends LbPairReadOnlyInterface {
  contractAddress: string;
  sender: string;
  swapTokens: (
    {
      expectedReturn,
      offer,
      padding,
      to,
    }: {
      expectedReturn?: Uint128;
      offer: TokenAmount;
      padding?: string;
      to?: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  receive: (
    {
      amount,
      from,
      msg,
      sender,
    }: {
      amount: Uint128;
      from: string;
      memo?: string;
      msg?: Binary;
      sender: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  addLiquidity: (
    {
      liquidityParameters,
    }: {
      liquidityParameters: LiquidityParameters;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  removeLiquidity: (
    {
      removeLiquidityParams,
    }: {
      removeLiquidityParams: RemoveLiquidity;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  collectProtocolFees: (
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  increaseOracleLength: (
    {
      newLength,
    }: {
      newLength: number;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  setStaticFeeParameters: (
    {
      baseFactor,
      decayPeriod,
      filterPeriod,
      maxVolatilityAccumulator,
      protocolShare,
      reductionFactor,
      variableFeeControl,
    }: {
      baseFactor: number;
      decayPeriod: number;
      filterPeriod: number;
      maxVolatilityAccumulator: number;
      protocolShare: number;
      reductionFactor: number;
      variableFeeControl: number;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  forceDecay: (
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  calculateRewards: (
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  resetRewardsConfig: (
    {
      baseRewardsBins,
      distribution,
    }: {
      baseRewardsBins?: number;
      distribution?: RewardsDistributionAlgorithm;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  setContractStatus: (
    {
      contractStatus,
    }: {
      contractStatus: ContractStatus;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
}
export class LbPairClient extends LbPairQueryClient implements LbPairInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.swapTokens = this.swapTokens.bind(this);
    this.receive = this.receive.bind(this);
    this.addLiquidity = this.addLiquidity.bind(this);
    this.removeLiquidity = this.removeLiquidity.bind(this);
    this.collectProtocolFees = this.collectProtocolFees.bind(this);
    this.increaseOracleLength = this.increaseOracleLength.bind(this);
    this.setStaticFeeParameters = this.setStaticFeeParameters.bind(this);
    this.forceDecay = this.forceDecay.bind(this);
    this.calculateRewards = this.calculateRewards.bind(this);
    this.resetRewardsConfig = this.resetRewardsConfig.bind(this);
    this.setContractStatus = this.setContractStatus.bind(this);
  }

  swapTokens = async (
    {
      expectedReturn,
      offer,
      padding,
      to,
    }: {
      expectedReturn?: Uint128;
      offer: TokenAmount;
      padding?: string;
      to?: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        swap_tokens: {
          expected_return: expectedReturn,
          offer,
          padding,
          to,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  receive = async (
    {
      amount,
      from,
      msg,
      sender,
    }: {
      amount: Uint128;
      from: string;
      memo?: string;
      msg?: Binary;
      sender: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        receive: {
          amount,
          from,
          memo,
          msg,
          sender,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  addLiquidity = async (
    {
      liquidityParameters,
    }: {
      liquidityParameters: LiquidityParameters;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        add_liquidity: {
          liquidity_parameters: liquidityParameters,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  removeLiquidity = async (
    {
      removeLiquidityParams,
    }: {
      removeLiquidityParams: RemoveLiquidity;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_liquidity: {
          remove_liquidity_params: removeLiquidityParams,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  collectProtocolFees = async (
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        collect_protocol_fees: {},
      },
      fee,
      memo,
      _funds
    );
  };
  increaseOracleLength = async (
    {
      newLength,
    }: {
      newLength: number;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        increase_oracle_length: {
          new_length: newLength,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  setStaticFeeParameters = async (
    {
      baseFactor,
      decayPeriod,
      filterPeriod,
      maxVolatilityAccumulator,
      protocolShare,
      reductionFactor,
      variableFeeControl,
    }: {
      baseFactor: number;
      decayPeriod: number;
      filterPeriod: number;
      maxVolatilityAccumulator: number;
      protocolShare: number;
      reductionFactor: number;
      variableFeeControl: number;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_static_fee_parameters: {
          base_factor: baseFactor,
          decay_period: decayPeriod,
          filter_period: filterPeriod,
          max_volatility_accumulator: maxVolatilityAccumulator,
          protocol_share: protocolShare,
          reduction_factor: reductionFactor,
          variable_fee_control: variableFeeControl,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  forceDecay = async (
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        force_decay: {},
      },
      fee,
      memo,
      _funds
    );
  };
  calculateRewards = async (
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        calculate_rewards: {},
      },
      fee,
      memo,
      _funds
    );
  };
  resetRewardsConfig = async (
    {
      baseRewardsBins,
      distribution,
    }: {
      baseRewardsBins?: number;
      distribution?: RewardsDistributionAlgorithm;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        reset_rewards_config: {
          base_rewards_bins: baseRewardsBins,
          distribution,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  setContractStatus = async (
    {
      contractStatus,
    }: {
      contractStatus: ContractStatus;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_contract_status: {
          contract_status: contractStatus,
        },
      },
      fee,
      memo,
      _funds
    );
  };
}
