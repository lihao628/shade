/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { ExecuteMsg, Addr, Uint256, Binary, Expiration, TokenAmount, TokenIdBalance, Metadata, Extension, Trait, MediaFile, Authentication, TransferAction, SendAction, TknConfig, InstantiateMsg, CurateTokenId, TokenInfoMsg, LbPair, QueryAnswer, TxAction, OwnerBalance, Tx, Permission, PermissionKey, StoredTokenInfo, QueryMsg, TokenPermissions, QueryWithPermit, PermitForTokenPermissions, PermitParamsForTokenPermissions, PermitSignature, PubKey } from "./LbToken.types";
export interface LbTokenReadOnlyInterface {
  contractAddress: string;
  tokenContractInfo: () => Promise<TokenContractInfoResponse>;
  idTotalBalance: ({
    id
  }: {
    id: string;
  }) => Promise<IdTotalBalanceResponse>;
  balance: ({
    key,
    owner,
    tokenId,
    viewer
  }: {
    key: string;
    owner: Addr;
    tokenId: string;
    viewer: Addr;
  }) => Promise<BalanceResponse>;
  allBalances: ({
    key,
    owner,
    txHistoryPage,
    txHistoryPageSize
  }: {
    key: string;
    owner: Addr;
    txHistoryPage?: number;
    txHistoryPageSize?: number;
  }) => Promise<AllBalancesResponse>;
  transactionHistory: ({
    address,
    key,
    page,
    pageSize
  }: {
    address: Addr;
    key: string;
    page?: number;
    pageSize: number;
  }) => Promise<TransactionHistoryResponse>;
  permission: ({
    allowedAddress,
    key,
    owner,
    tokenId
  }: {
    allowedAddress: Addr;
    key: string;
    owner: Addr;
    tokenId: string;
  }) => Promise<PermissionResponse>;
  allPermissions: ({
    address,
    key,
    page,
    pageSize
  }: {
    address: Addr;
    key: string;
    page?: number;
    pageSize: number;
  }) => Promise<AllPermissionsResponse>;
  tokenIdPublicInfo: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<TokenIdPublicInfoResponse>;
  tokenIdPrivateInfo: ({
    address,
    key,
    tokenId
  }: {
    address: Addr;
    key: string;
    tokenId: string;
  }) => Promise<TokenIdPrivateInfoResponse>;
  registeredCodeHash: ({
    contract
  }: {
    contract: Addr;
  }) => Promise<RegisteredCodeHashResponse>;
  withPermit: ({
    permit,
    query
  }: {
    permit: PermitForTokenPermissions;
    query: QueryWithPermit;
  }) => Promise<WithPermitResponse>;
}
export class LbTokenQueryClient implements LbTokenReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.tokenContractInfo = this.tokenContractInfo.bind(this);
    this.idTotalBalance = this.idTotalBalance.bind(this);
    this.balance = this.balance.bind(this);
    this.allBalances = this.allBalances.bind(this);
    this.transactionHistory = this.transactionHistory.bind(this);
    this.permission = this.permission.bind(this);
    this.allPermissions = this.allPermissions.bind(this);
    this.tokenIdPublicInfo = this.tokenIdPublicInfo.bind(this);
    this.tokenIdPrivateInfo = this.tokenIdPrivateInfo.bind(this);
    this.registeredCodeHash = this.registeredCodeHash.bind(this);
    this.withPermit = this.withPermit.bind(this);
  }

  tokenContractInfo = async (): Promise<TokenContractInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_contract_info: {}
    });
  };
  idTotalBalance = async ({
    id
  }: {
    id: string;
  }): Promise<IdTotalBalanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      id_total_balance: {
        id
      }
    });
  };
  balance = async ({
    key,
    owner,
    tokenId,
    viewer
  }: {
    key: string;
    owner: Addr;
    tokenId: string;
    viewer: Addr;
  }): Promise<BalanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      balance: {
        key,
        owner,
        token_id: tokenId,
        viewer
      }
    });
  };
  allBalances = async ({
    key,
    owner,
    txHistoryPage,
    txHistoryPageSize
  }: {
    key: string;
    owner: Addr;
    txHistoryPage?: number;
    txHistoryPageSize?: number;
  }): Promise<AllBalancesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_balances: {
        key,
        owner,
        tx_history_page: txHistoryPage,
        tx_history_page_size: txHistoryPageSize
      }
    });
  };
  transactionHistory = async ({
    address,
    key,
    page,
    pageSize
  }: {
    address: Addr;
    key: string;
    page?: number;
    pageSize: number;
  }): Promise<TransactionHistoryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      transaction_history: {
        address,
        key,
        page,
        page_size: pageSize
      }
    });
  };
  permission = async ({
    allowedAddress,
    key,
    owner,
    tokenId
  }: {
    allowedAddress: Addr;
    key: string;
    owner: Addr;
    tokenId: string;
  }): Promise<PermissionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      permission: {
        allowed_address: allowedAddress,
        key,
        owner,
        token_id: tokenId
      }
    });
  };
  allPermissions = async ({
    address,
    key,
    page,
    pageSize
  }: {
    address: Addr;
    key: string;
    page?: number;
    pageSize: number;
  }): Promise<AllPermissionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_permissions: {
        address,
        key,
        page,
        page_size: pageSize
      }
    });
  };
  tokenIdPublicInfo = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<TokenIdPublicInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_id_public_info: {
        token_id: tokenId
      }
    });
  };
  tokenIdPrivateInfo = async ({
    address,
    key,
    tokenId
  }: {
    address: Addr;
    key: string;
    tokenId: string;
  }): Promise<TokenIdPrivateInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_id_private_info: {
        address,
        key,
        token_id: tokenId
      }
    });
  };
  registeredCodeHash = async ({
    contract
  }: {
    contract: Addr;
  }): Promise<RegisteredCodeHashResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      registered_code_hash: {
        contract
      }
    });
  };
  withPermit = async ({
    permit,
    query
  }: {
    permit: PermitForTokenPermissions;
    query: QueryWithPermit;
  }): Promise<WithPermitResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      with_permit: {
        permit,
        query
      }
    });
  };
}
export interface LbTokenInterface extends LbTokenReadOnlyInterface {
  contractAddress: string;
  sender: string;
  mintTokens: ({
    memo,
    mintTokens,
    padding
  }: {
    memo?: string;
    mintTokens: TokenAmount[];
    padding?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  burnTokens: ({
    burnTokens,
    memo,
    padding
  }: {
    burnTokens: TokenAmount[];
    memo?: string;
    padding?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeMetadata: ({
    privateMetadata,
    publicMetadata,
    tokenId
  }: {
    privateMetadata?: Metadata;
    publicMetadata?: Metadata;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transfer: ({
    amount,
    from,
    memo,
    padding,
    recipient,
    tokenId
  }: {
    amount: Uint256;
    from: Addr;
    memo?: string;
    padding?: string;
    recipient: Addr;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  batchTransfer: ({
    actions,
    padding
  }: {
    actions: TransferAction[];
    padding?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  send: ({
    amount,
    from,
    memo,
    msg,
    padding,
    recipient,
    recipientCodeHash,
    tokenId
  }: {
    amount: Uint256;
    from: Addr;
    memo?: string;
    msg?: Binary;
    padding?: string;
    recipient: Addr;
    recipientCodeHash?: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  batchSend: ({
    actions,
    padding
  }: {
    actions: SendAction[];
    padding?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  givePermission: ({
    allowedAddress,
    padding,
    tokenId,
    transfer,
    transferExpiry,
    viewBalance,
    viewBalanceExpiry,
    viewPrivateMetadata,
    viewPrivateMetadataExpiry
  }: {
    allowedAddress: Addr;
    padding?: string;
    tokenId: string;
    transfer?: Uint256;
    transferExpiry?: Expiration;
    viewBalance?: boolean;
    viewBalanceExpiry?: Expiration;
    viewPrivateMetadata?: boolean;
    viewPrivateMetadataExpiry?: Expiration;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  revokePermission: ({
    allowedAddress,
    owner,
    padding,
    tokenId
  }: {
    allowedAddress: Addr;
    owner: Addr;
    padding?: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createViewingKey: ({
    entropy,
    padding
  }: {
    entropy: string;
    padding?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setViewingKey: ({
    key,
    padding
  }: {
    key: string;
    padding?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  revokePermit: ({
    padding,
    permitName
  }: {
    padding?: string;
    permitName: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  registerReceive: ({
    codeHash,
    padding
  }: {
    codeHash: string;
    padding?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class LbTokenClient extends LbTokenQueryClient implements LbTokenInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.mintTokens = this.mintTokens.bind(this);
    this.burnTokens = this.burnTokens.bind(this);
    this.changeMetadata = this.changeMetadata.bind(this);
    this.transfer = this.transfer.bind(this);
    this.batchTransfer = this.batchTransfer.bind(this);
    this.send = this.send.bind(this);
    this.batchSend = this.batchSend.bind(this);
    this.givePermission = this.givePermission.bind(this);
    this.revokePermission = this.revokePermission.bind(this);
    this.createViewingKey = this.createViewingKey.bind(this);
    this.setViewingKey = this.setViewingKey.bind(this);
    this.revokePermit = this.revokePermit.bind(this);
    this.registerReceive = this.registerReceive.bind(this);
  }

  mintTokens = async ({
    memo,
    mintTokens,
    padding
  }: {
    memo?: string;
    mintTokens: TokenAmount[];
    padding?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mint_tokens: {
        memo,
        mint_tokens: mintTokens,
        padding
      }
    }, fee, memo, _funds);
  };
  burnTokens = async ({
    burnTokens,
    memo,
    padding
  }: {
    burnTokens: TokenAmount[];
    memo?: string;
    padding?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn_tokens: {
        burn_tokens: burnTokens,
        memo,
        padding
      }
    }, fee, memo, _funds);
  };
  changeMetadata = async ({
    privateMetadata,
    publicMetadata,
    tokenId
  }: {
    privateMetadata?: Metadata;
    publicMetadata?: Metadata;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_metadata: {
        private_metadata: privateMetadata,
        public_metadata: publicMetadata,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  transfer = async ({
    amount,
    from,
    memo,
    padding,
    recipient,
    tokenId
  }: {
    amount: Uint256;
    from: Addr;
    memo?: string;
    padding?: string;
    recipient: Addr;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer: {
        amount,
        from,
        memo,
        padding,
        recipient,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  batchTransfer = async ({
    actions,
    padding
  }: {
    actions: TransferAction[];
    padding?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      batch_transfer: {
        actions,
        padding
      }
    }, fee, memo, _funds);
  };
  send = async ({
    amount,
    from,
    memo,
    msg,
    padding,
    recipient,
    recipientCodeHash,
    tokenId
  }: {
    amount: Uint256;
    from: Addr;
    memo?: string;
    msg?: Binary;
    padding?: string;
    recipient: Addr;
    recipientCodeHash?: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send: {
        amount,
        from,
        memo,
        msg,
        padding,
        recipient,
        recipient_code_hash: recipientCodeHash,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  batchSend = async ({
    actions,
    padding
  }: {
    actions: SendAction[];
    padding?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      batch_send: {
        actions,
        padding
      }
    }, fee, memo, _funds);
  };
  givePermission = async ({
    allowedAddress,
    padding,
    tokenId,
    transfer,
    transferExpiry,
    viewBalance,
    viewBalanceExpiry,
    viewPrivateMetadata,
    viewPrivateMetadataExpiry
  }: {
    allowedAddress: Addr;
    padding?: string;
    tokenId: string;
    transfer?: Uint256;
    transferExpiry?: Expiration;
    viewBalance?: boolean;
    viewBalanceExpiry?: Expiration;
    viewPrivateMetadata?: boolean;
    viewPrivateMetadataExpiry?: Expiration;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      give_permission: {
        allowed_address: allowedAddress,
        padding,
        token_id: tokenId,
        transfer,
        transfer_expiry: transferExpiry,
        view_balance: viewBalance,
        view_balance_expiry: viewBalanceExpiry,
        view_private_metadata: viewPrivateMetadata,
        view_private_metadata_expiry: viewPrivateMetadataExpiry
      }
    }, fee, memo, _funds);
  };
  revokePermission = async ({
    allowedAddress,
    owner,
    padding,
    tokenId
  }: {
    allowedAddress: Addr;
    owner: Addr;
    padding?: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke_permission: {
        allowed_address: allowedAddress,
        owner,
        padding,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  createViewingKey = async ({
    entropy,
    padding
  }: {
    entropy: string;
    padding?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_viewing_key: {
        entropy,
        padding
      }
    }, fee, memo, _funds);
  };
  setViewingKey = async ({
    key,
    padding
  }: {
    key: string;
    padding?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_viewing_key: {
        key,
        padding
      }
    }, fee, memo, _funds);
  };
  revokePermit = async ({
    padding,
    permitName
  }: {
    padding?: string;
    permitName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke_permit: {
        padding,
        permit_name: permitName
      }
    }, fee, memo, _funds);
  };
  registerReceive = async ({
    codeHash,
    padding
  }: {
    codeHash: string;
    padding?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_receive: {
        code_hash: codeHash,
        padding
      }
    }, fee, memo, _funds);
  };
}